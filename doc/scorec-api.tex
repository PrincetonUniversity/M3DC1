\section{SCOREC API}
This appendix chapter should document all SCOREC/ITAPS functions called from M3D-C$^1$. 
In this document the term process is used instead of processor since multiple processes
may be run on a single processor.  Currently it is assumed that there is
one partition per process.  In Fortran, the standard convention
is that a function does not modify any passed in variables and returns a value. 
In this appendix a function follows C/C++ conventions in both syntax and functionality. 
Functions listed below should be thought of as Fortran subroutines as they are allowed
to modify the passed in parameters and do not return any value. 
The datatypes listed below in the C/C++ functions are:
\begin{description}
\item[int *] A 4 byte integer in Fortran.
\item[int[X]] A 4 byte integer array that should be allocated of at least length \textit{X}.
\item[char *] A character string in Fortran.
\item[double *] An 8 byte double precision/real*8 variable in Fortran. When using complex variables this may also be a 16 byte double precision complex number.  
\item[double[X]]  An 8 byte double precision/real*8 variable array in Fortran of at least length \textit{X}.  When using complex variables this may also be a 16 byte double precision complex array of \textit{X}*16 bytes length.
\end{description}
To make clear what is discussed below, a mesh vertex, edge, and face are the topological
entities of a mesh.  Many people associate nodes of a mesh with mesh vertices and elements with
the mesh faces for 2D meshes.  

The \textit{clearscorecdata} function cleans up everything associated with the SCOREC libraries.
Beyond this, there are 5 main sets of functions: model, mesh, ordering, vector and matrix.  The model
interface can be thought of as an independent object and is used to represent the geometric domain independent
of any mesh discretizing it.  The mesh only depends on the model that it discretizes.  The ordering
depends on the mesh and the model only and gives numberings of the degrees-of-freedom (DOFs) associated
with mesh entities (for the reduced quintic DOFs are only associated with mesh vertices).  The vector
and matrix interface depends mainly on the ordering but indirectly on the model and mesh as well.
 The two main functions
are to load a mesh and model which is used with the \textit{loadmesh} function below.  
\begin{center}
\begin{figure}
%\centerline{\psfig{figure=./partitioned_mesh.eps,height=2.5in,angle=0}} %for epsfig
\caption{A partitioned mesh with the DOFs locally numbered for the blue partition with one DOF per node and iper=1 and jper=0.}\label{meshpartition} \end{figure}
\end{center}


\begin{itemize}
\item void loadmesh( char * modelfilename, char * meshfilename); This function
loads a model file called \textit{modelfilename} which should be ``struct.dmg'' 
and a mesh file called \textit{meshfilename} which should be ``struct-dmg.sms''.
\item void clearscorecdata(); This function clears all SCOREC software data.
\end{itemize}


\subsection{Model Interface}
\begin{itemize}
\item  void getmodeltags(int * bottom, int * right, int * top, int * left); This
function assumes that the domain is rectangular shaped and returns the four model entity 
IDs for the sides of the rectangle.  The main use of this function is for setting boundary 
conditions on DOFs associated with mesh entities classified on the boundary.  The mesh entity
classification is obtained through the \textit{zonedg} function 
for mesh edges and \textit{zonenod} function for
mesh nodes/vertices.
\item  void setperiodicinfo(int* xperiodic, int* zperiodic); Sets the flag that periodic
boundary conditions exist in the horizontal direction if \textit{xperiodic} is anything but zero
and that periodic
boundary conditions exist in the vertical direction if \textit{zperiodic} is anything but zero.
\item  void getperiodicinfo(int * xperiodic, int* zperiodic);	Gets the flag that periodic
boundary conditions exist.  If \textit{xperiodic} is one than they have been set in
the horizontal direction and zero if they have not been. If
 \textit{zperiodic} is one than they have been set in
the vertical direction and zero if they have not been.
\item  void getmincoord(double* xmin, double* zmin); Gets the minimum coordinate dimensions of the geometric domain. 
\textit{xmin} is the minimum horizontal coordinate value and \textit{zmin} is the minimum vertical coordinate value
returned by the function.
\item  void getmaxcoord(double* xmax, double* zmax); Gets the maximum coordinate dimensions of the geometric domain.  
\textit{xmax} is the maximum horizontal coordinate value and \textit{zmax} is the maximum vertical coordinate value
returned by the function.
\end{itemize}

\subsection{Mesh Interface}
\begin{itemize}
\item void numnod( int *NumNodes ) ; Returns the number of nodes, \textit{NumNodes}, in the process's partition of the mesh.  Since
 some nodes  exist on partition boundaries (i.e. shared by multiple processes) summing \textit{NumNodes} over all
processes will result in more nodes than exist in the total mesh. The IDs of the nodes on a process are numbered between
one and \textit{NumNodes}.
\item void xyznod( int *iNode , double X[3] ) ; For input node ID \textit{iNode}, this function returns the coordinate location in 
the \textit{X} array.  The \textit{X} array should be of at least length 3.
\item void numfac( int *NumFaces ) ; Returns the number of faces, \textit{NumFaces}, in the process's partition of the mesh. 
For a 2D mesh, the faces will all be elements. Since
 any face for a 2D mesh  exists only on  one partition,  summing \textit{NumFaces} over all
processes will result in the total number of faces that exist in the mesh. The IDs of the faces on a process are numbered between
one and \textit{NumFaces}.
\item void nodfac( int *iFace, int Nodes[4] ) ; For an input face ID, \textit{iFace}, this function returns the adjacent nodal IDs
in the \textit{Nodes} array.  
For mixed topology meshes the faces could be triangles or quadrilaterals so it is safest to have the \textit{Nodes} array to be of
length four.  The nodes' IDs are returned in counter-clockwise order and if the face is a triangle then only the first three
values in the \textit{Nodes} array contain usable data.
\item void numglobalents(int * numnodes, int * numedges, int * numfaces, int * numregions); This function returns
the global number of nodes, edges, faces, and regions in the mesh in \textit{numnodes, numedges, numfaces}, and \textit{numregions}.
\item  void zonenod( int *iNod , int *iZone , int * iZoneDim); This function returns the model entity ID in 
\textit{iZone} and the model entity dimension in \textit{iZoneDim} for passed in mesh vertex \textit{iNod}.
\item void zonedg( int *iEdge , int *iZone , int * iZoneDim ); This function returns the model entity ID in 
\textit{iZone} and the model entity dimension in \textit{iZoneDim} for passed in mesh edge \textit{iEdge}.

\item void createsearchstructure(); This function sets up a search structure on each mesh partition.  
\item void deletesearchstructure(); This function deletes the search structure on each mesh partition.
\item void usesearchstructure(double* x, double* y, int* iFace); This function returns the face ID \textit{iFace}
of a mesh face that contains the given point \textit{(x,y)}.  The point \textit{(x,y)} is given in the
global coordinate system of the mesh.  The function returns -1 for \textit{iFace} if the point is not contained
in the domain of any mesh faces on the local process's partition.  Note  that multiple faces may contain
a given point (e.g. a mesh vertex coordinate).
\item void getelmsizes(int * iFace, double sizes[4]); For mesh face \textit{iFace}, this function returns an array
of doubles for the mesh size at each of the mesh vertices of the face.  
\end{itemize}





\subsection{Ordering Interface}
It should be noted that when using complex numbers that the orderings will act the same regardless
of the data type. As an example, for DOF number \textit{i}, the double precision array value will 
be stored at \textit{d(i)} and the complex array value will be stored at \textit{c(i)}.  Since
C and C++ have no intrinsic complex datatype, the complex arrays will be treated as double arrays
and the real part will be accessed at \textit{d[(i-1)*2]} and the imaginary part will be
accessed at \textit{d[(i-1)*2+1]}.

\begin{itemize}
\item   void createdofnumbering(int * numberingid, int * iper, int * jper,
                           int * dofspervertex, int * dofsperedge, 
                           int* dofsperface, int * dofsperregion, int * numdofs);
 This function creates a numbering with  ID \textit{numberingid}.  Currently, \textit{iper}
and \textit{jper} are not used as the periodic information is read in from the C1input file during the 
call to \textit{loadmesh}.
Eventually though if some orderings are periodic and others are not (e.g. a potential function)
than these options can be used to specify the difference in orderings. The other parameters
passed in (\textit{dofspervertex, dofsperedge, dofsperface,dofsperregion}) are to specify
how many DOFs per mesh entity type (e.g. \textit{dofspervertex} would be 18 for a numvar=3 
vector and 0 for the other mesh entity types).  The only returned value is \textit{numdofs} 
which is the total number of DOFs associated with mesh entities that exist on the process that
the function is called on. This is also the allocated size of a vector on this process.  Note
though that a global sum of \textit{numdofs} on all processes will be greater than the total number
of global DOFs unless it is a single process run. 

\item void deletedofnumbering(int * numberingid);
This function deletes the numbering associated with \textit{numberingid}.  It is an error
to query the SCOREC software with \textit{numberingid} after it has been deleted
unless another numbering is created
with this id.


\item  void entdofs(int * numberingid, int * meshentid, int * meshentdim,
               int * begindofnumber, int * enddofnumberplusone);
     For \textit{numberingid}, of topological dimension \textit{meshentdim} with mesh entity
ID \textit{meshentid} this function outputs \textit{begindofnumber} which is the beginning of
the DOF array location (stored contiguously) and \textit{enddofnumberplusone} is one
beyond the last DOF array location.  Note that the returned array index values are in Fortran
ordering convection such that the first entry of the array is at index 1.
For a numvar=1 ordering an example would be \textit{begindofnumber}=1
and \textit{enddofnumberplusone}=7. 

\item  void numdofs(int * numberingid, int * numdofs); This function returns the total number of 
DOFs associated with all mesh entities existing on a specific mesh partition.  For the example
in Figure \ref{meshpartition}, the blue partition would have \textit{numdofs} equal to 10 as both DOF 1
and 2 are periodic DOFs and only get counted once even though the number of nodes for this 
partition is 12.
  
\item  void numglobaldofs(int * numberingid, int * numglobaldofs);
This function returns the global number of DOFs \textit{numglobaldofs} for numbering \textit{numberingid}. 
 For the mesh in Figure \ref{meshpartition} with given periodicity \textit{numglobaldofs} would be 19.

\end{itemize}
\subsection{Vector Interface}
It is the responsibility of M3D-C$^1$ to allocate and deallocate memory for vectors.  The \textit{space}
subroutine in M3D-C$^1$ is used for allocating and deallocating all vectors of DOFs of fields
that are to be transferred during mesh adaptation.  This is used as a ``callback'' function to 
manage the memory of these arrays.  The proper amount of memory to be allocated for each vector
is obtained by using the \textit{numdofs} function for the same numbering id that is used
for the vector.

On the SCOREC side of the software, all arrays are considered to be arrays of double precision numbers.
Determining if they are actual double precision numbers (8 bytes) or complex double precision numbers
(16 bytes) is done through the \textit{type} parameter for both vector and matrix interfaces 
(\textit{itype}=0 indicates real-valued and \textit{itype}=1 indicates complex-valued).  

\begin{itemize}
\item   void createppplvec(double */complex * vectorid, int * orderingid, int * type); This function creates a vector 
for \textit{vectorid}
 for numbering \textit{orderingid}. If the vector is for a real-valued array \textit{type}
should be set to 0 and if the vector is for  a complex-valued array \textit{type} should be set to 1. 
\item   void deleteppplvec(double */complex * vectorid); This function deletes the vector but it is M3D-C$^1$'s 
responsibility to deallocate the memory used for the array.
\item   void sumsharedppplvecvals(double */complex * vectorid);  This function assumes that the values inserted into the
array of the vector has only local contributions on each process and then this sums the parts
of the vector that are distributed across multiple processes and updates each of those values
to a single value.  An example of this would be to figure out how many mesh faces use each DOF.  To do this, 
first zero the vector, then 
iterate over all of the faces on each process, then iterate over each mesh vertex, get the DOFs
associated with each vertex and add 1 to each array indexed with the DOF number, then call this function.
For this operation, for DOF number 10 in Figure \ref{meshpartition} the number would be 7.
\item   void updatesharedppplvecvals(double */complex * vectorid);  This function assumes that the single process that ``owns'' a DOF
has the correct value and that other processes that need the DOF may or may not have the correct value.  With
this assumption, this function can be called to update the correct values for a DOF on processes
that need the DOF but do not own it.  This is used primarily for distributing the DOF values after a matrix solve
from the process it was solved for on to the other processes that use the DOF.  This function might not be useful
for M3D-C$^1$ but is documented anyways.
\item   void checkppplveccreated(double */complex * vectorid, int * iscreated); This function checks whether a vector \textit{vectorid} 
has already been created or not.  It returns 0 if it has not and 1 if it has been created but does no
action otherwise.  
\item void checksameppplvec(double */complex * id1, double */complex * id2, int * i); This function checks if vectors 
\textit{id1} and \textit{id2} are the same, and sets *i=1 if true, *i=0 if false
\end{itemize}

\subsection{Matrix Interface}
Note that some of these functions may have a ``2'' at the end of their names to make sure
that modifications done to get to using complex variables was done with less errors. As was done with
vectors, \textit{type} is used to indicate real-valued matrices (\textit{type}=0) and complex-valued
matrices (\textit{type}=1).
\begin{itemize}
\item  void zerosuperlumatrix(int * matrixid, it * type, int * numberingid);  This function creates
an ``empty'' matrix with id \textit{matrixid} that uses the numbering \textit{numberingid}
for use with the SuperLU\_DIST solver.  If the matrix is real-valued then \textit{type}
should be set to 0 and if the matrix is complex-valued then \textit{type} should be set to 1. 
If the matrix has already been created then it just cleans out all components of the matrix.
\item  void zeropetscmatrix(int * matrixid, int * type, int * numberingid); This function creates
an ``empty'' matrix with id \textit{matrixid} that uses the numbering \textit{numberingid}
for use with the SuperLU\_DIST solver.  If the matrix is real-valued then \textit{type}
should be set to 0 and if the matrix is complex-valued then \textit{type} should be set to 1. 
If the matrix has already been created then it just cleans out all components of the matrix.
 \item void zeromultiplymatrix(int * matrixid, int * type, int * numberingid); This function creates
an ``empty'' matrix with id \textit{matrixid} that uses the numbering \textit{numberingid}
for use for multiplying with vectors.  If the matrix is real-valued then \textit{type}
should be set to 0 and if the matrix is complex-valued then \textit{type} should be set to 1. 
If the matrix has already been created then it just cleans out all components of the matrix.
\item  void insertval(int * matrixid, double */complex * val, int * valtype, int * row, 
		   int * column, int * operation);  This function inserts \textit{val} into
matrix \textit{matrixid} at \textit{(row,column)} in the matrix where \textit{row}
and \textit{column} come from the ordering.  The type of value to
 be inserted can be real (\textit{valtype}=0)
or complex (\textit{valtype}=1).  A real type can be inserted into a complex matrix but
a complex type cannot be inserted into a real matrix.  If \textit{operation}
is zero then the value overwrites any existing value, otherwise the value is to be added
to existing values for that matrix component.
\item  void setdiribc(int * matrixid, int * row);  For matrix \textit{matrixid}, this function
zeroes out all off-diagonal values for \textit{row} and sets the diagonal value to unity.  The operation is
actually carried out during \textit{finalizematrix} so this function can be called before other values
are inserted into that row while still applying the correct operation.  For complex-valued arrays, 
only the real part of the diagonal is set to unity while the imaginary part is set to 0.  This function 
should be called on all processes that use the DOF number associated with the matrix row.
\item  void setgeneralbc(int * matrixid, int * row, int * numvals,
		     int  columninfo[numvals], double/complex vals[numvals], int * type);
This function sets multiple values for \textit{row} of \textit{matrixid}.  The number of values set is
\textit{numvals} and \textit{columninfo} specifies which columns to set the values for and 
\textit{vals} is the values to be set which must be in the same order as the \textit{columninfo} array.
 The type of values to
 be inserted can be real (\textit{type}=0)
or complex (\textit{type}=1). If only real values are inserted into a complex matrix then the corresponding
imaginary parts are set to zero.
This function 
should be called on all processes that use the DOF number associated with the matrix row.
\item  void finalizematrix(int * matrixid);  This function finalizes \textit{matrixid} such that no
more values can be inserted into the matrix and no more boundary conditions can be applied to the matrix.
\item  void solve(int * matrixid, double */complex * rhs\_sol, int * ier);  For a matrix created with \textit{zeropetscmatrix}
or \textit{zerosuperlumatrix}, \textit{matrixid} is solved with input right-hand-side \textit{rhs\_sol}. 
The output  is also in \textit{rhs\_sol}.  If \textit{ier} is non-zero there were problems encountered during
the solve process.  The only way to properly mix real and complex value types is if the matrix is real-valued
and the vector is complex-valued.  Then the system is solved twice with a real and an imaginary right-hand-side.  
\item  void matrixvectormult(int * matrixid, double */complex * inputvecid, double */complex * outputvecid);  For a matrix created with \textit{zeromultiplymatrix}, this function can be called to multiply \textit{matrixid} with \textit{inputvecid}.  The output is returned in \textit{outputvecid}.  If either \textit{matrixid} or \textit{inputvecid}
is complex-valued, \textit{outputvecid} must also be complex-valued.
\item  void deletematrix(int * matrixid);  This function deletes the matrix with ID \textit{matrixid}.
\item  void matrixrank(int* matrixid, int * rank);  This function returns the global rank of \textit{matrixid}
in \textit{rank}.  This value is the same as the returned value for \textit{numglobaldofs} for the matrix's
ordering.
\item  void initsolvers();  This function sets up the data structures required by the solvers.
\item  void finalizesolvers();  This function finalizes/destroys the data structures required by the solvers.
\item  void writematrixtofile(int * matrixid, int * fileid);  This function writes out the non-zero components
of \textit{matrixid} to a file that uses \textit{fileid} to indicate which file.
\end{itemize}
For the PETSc solver, the following two functions are defined in \textit{PETScInterface.c} and are designed
to give M3D-C$^1$ the ability to modify the PETSc solver parameters for a given \textit{matrixid}.  
The FortranMatrixID enumeration must match the parameters specified in the sparse module in \textit{M3Dmodules.f90}.
\begin{itemize}
\item  int setPETScMat(int matrixid, Mat * A);  This function can be used to set options for storing \textit{matrix}
in PETSc data structures.
\item int setPETScKSP(int matrixid, KSP * ksp, Mat * A); This function can be used to set the solver
parameters for \textit{matrixid} in PETSc.
\end{itemize}

\subsection{Creating Meshes for M3D-C$^1$}
There are a couple of ways to create meshes for M3D-C$^1$ simulations.  

The first procedure for generating an initial mesh is using the 
structMesh.cc code in 
M3D-C$^1$ in the Util subdirectory (i.e. M3D/Util/structMesh.cc).  This code
 creates a 2D structured mesh that can be used with FMDB.  Compilation is done with
 \textit{$<$C++ compiler$>$ -o structMesh.x structMesh.cc} and the input for the code is
\textit{./structMesh.x $<$number of nodes in the x-direction$>$ $<$number of nodes in the z-direction$>$ 
$<$x-length or rectangular domain$>$ $<$z-length of rectangular domain$>$}
Note that the domain is 0 $<$= x $<$= x-length or rectangular domain , 0 $<$= z $<$= z-length of rectangular domain.
After running structMesh.x, the output will be a file called struct.sms.  To be
able to use this with M3D-C$^1$, this file must be processed by running the program
in \textit{$<$SCOREC SOFTWARE PATH$>$/mctk/Examples/PPPL/PPPL/test/DISCRETE/main} with the argument struct.sms 
(e.g. $<$SCOREC SOFTWARE PATH$>$/mctk/Examples/PPPL/PPPL/test/DISCRETE/main struct.sms)
which will output a struct-dmg.sms and struct.dmg file which can be used to
run M3D-C1.

The second procedure for generating an initial mesh is to use the Simmetrix (www.simmetrix.com)
mesh generation tools.  Some code already exists at SCOREC for creating meshes for PPPL 
using the Simmetrix
software and MCTK but this code is not available on PPPL machines or bassi.nersc.gov as the
Simmetrix software API is copyrighted and not available for general public distribution.  The two main
desired functionalities that the Simmetrix software provides are generating unstructured meshes
for an inputed analytic sizefield and the ability to create ``matching meshes'' for
periodic boundary conditions (e.g. meshes
that match vertex locations on periodic model boundaries).  The Simmetrix mesh generation tools
specific to PPPL are located in /users/acbauer/develop/mctk/generate\_mesh/generate\_mesh/test
subdirectories but have not been added to the MCTK repository since this is specific to PPPL work.
The build system is the usual SCOREC build system available in 
/users/acbauer/develop/mctk/generate\_mesh/generate\_mesh/
along with the executables in the test subdirectory.  Running these executables typically
is done by \textit{./main $<$ACIS/Parasolid model file$>$ $<$size parameter$>$ $<$curvature parameter$>$}
and the output is a mesh in both Simmetrix file format (*\_SimModS.sms) and
FMDB file format (*\_FMDB.sms).  The FMDB file format must then be processed as the struct.sms file
for the structured mesh generation tool above to create the struct.dmg and struct-dmg.sms files.

The third procedure for creating an adapted mesh from an M3D-C$^1$ run is to use the 
\textit{hessianadapt} function in the SCOREC software.  The function parameters in C/C++ are:\\
\textit{void hessianadapt(double */complex * ppplvector, int * which, int * type, int * ntime, double * factor, double * hmin, double * hmax);}\\
Here, \textit{ppplvector} is a pointer to an array of double precisions or complex double precisions
used to store the DOFs of the desired fields, \textit{which} is used to indicate the specific field
since ppplvector may store DOFs for more than a single field and is a number between 1 and the total
number of fields that store their DOFs in the ppplvector, 
\textit{type} indicates whether to use the real part or imaginary part if the DOFs are complex valued, 
\textit{ntime} is the time step to adapt the field with respect to (the field may have been created
and stored in SCOREC software already from a previous time step and this is used to make sure that
the adaptation is done with respect to the most current time step),
\textit{factor} is the refinement factor, \textit{hmin} is the desired minimum edge length in the adapted mesh, 
and \textit{hmax} is the desired maximum edge length in the adapted mesh.  Note that the actual
minimum and maximum desired edges lengths may be smaller and larger, respectively, than the
desired values.  The \textit{factor, hmin,} and \textit{hmax} parameters are the same as the ones
used in Ken Jansen's phAdapt software.  This adaptation procedure only works with single process
runs of M3D-C$^1$ and the adapted mesh is classified on the same model (struct.dmg) 
as the pre-adapted mesh.  During mesh adaptation, all fields that exist as PPPLVectors are transferred
using interpolation during local mesh modifications.  These values are then passed back to M3D-C$^1$ by
resizing the arrays of DOFs that M3D-C$^1$ uses and then setting the DOF values for these arrays.  
The resizing of the DOF arrays will be done in the /textit{space} subroutine in M3D-C$^1$.


% appendix on modules that are used on different machines that M3D-C1 is installed on
\subsubsection{Module use on different machines}
This appendix is meant to make sure that people do not have trouble determining which modules to use on 
which machines.  Note that this list may include modules that are not necessary for M3D-C$^1$.

\subsubsection{viz/m3d.pppl.gov}
The modules that I (Andy Bauer) have loaded on viz and m3d are  
 intel\_fc/9.0.033,
 intel\_cc/9.0.032,
 ncarg/4.4.1,
 hdf5/1.6.5,
 intel\_mkl/8.1.014,
   superlu\_dist\_2.0/20060102,
   intel\_vt/8.0.245,
   subversion/1.3.0,
   /parmetis/3.1,
  /autopack/1.3.2,
  petsc/2.3.3-p3,
  superlu\_3.0/20060102, and
  /zoltan/3.0 .

The commands that I use to load them are:
\begin{itemize}
\item      module load intel\_fc/9.0.033
\item       module load intel\_cc/9.0.032
\item       module load ncarg
\item       module load hdf5
\item       module load intel\_mkl/8.1.014
\item       module load superlu\_dist\_2.0/20060102
\item       module load intel\_vt
\item       module load subversion
\item       module load intel\_cc parmetis
\item       module load intel\_cc autopack
\item       module load petsc
\item       module load superlu\_3.0
\item       module load zoltan
\end{itemize}

\subsubsection{bassi.nersc.gov}
The modules that I (Andy Bauer) have loaded on bassi are 
null
   parmetis/3.1
   superlu\_dist/2.0\_64
   hdf5\_par/1.6.4
   netcdf/3.6.2
   ncar/4.4.2
   lapack/3.0
   petsc/2.3.3\_O
   zoltan/3.0 .

The commands that I use to load them are:
\begin{itemize}
\item module load parmetis
\item module load superlu\_dist
\item module load hdf5\_par
\item module load netcdf
\item module load ncar
\item module load petsc/2.3.3\_O
\item module load lapack
\item module load zoltan
\end{itemize}

