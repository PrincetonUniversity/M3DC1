\appendix
\chapter{SCOREC Software Interface}

\begin{center}
\begin{figure}
\centerline{\psfig{figure=./partitioned_mesh.eps,height=2.5in,angle=0}} %for epsfig
\caption{A partitioned mesh with the dofs numbered for the blue partition with one dof per node and iper=1 and jper=0.}\label{meshpartition} \end{figure}
\end{center}


\begin{itemize}
\item void loadmesh( char * modelfilename, char * meshfilename); This function
loads a model file called \textit{modelfilename} which should be ``struct.dmg'' 
and a mesh file called \textit{meshfilename} which should be ``struct-dmg.sms''.
\item void clearscorecdata(); This function clears all SCOREC software data.
\end{itemize}


\section{Model Interface}
\begin{itemize}
\item  void getmodeltags(int * bottom, int * right, int * top, int * left); This
function assumes that the domain is rectangular shaped and returns the four model entity 
IDs for the sides of the rectangle.  The main use of this function is for setting boundary 
conditions on DOFs associated with mesh entities classified on the boundary.  The mesh entity
classification is obtained through the \textit{zonedg} function 
for mesh edges and \textit{zonenod} function for
mesh nodes/vertices.
\item  void setperiodicinfo(int* xperiodic, int* zperiodic); Sets the flag that periodic
boundary conditions exist in the horizontal direction if \textit{xperiodic} is anything but zero
and that periodic
boundary conditions exist in the vertical direction if \textit{zperiodic} is anything but zero.
\item  void getperiodicinfo(int * xperiodic, int* zperiodic);	Gets the flag that periodic
boundary conditions exist.  If \textit{xperiodic} is one than they have been set in
the horizontal direction and zero if they have not been. If
 \textit{zperiodic} is one than they have been set in
the vertical direction and zero if they have not been.
\item  void getmincoord(double* xmin, double* zmin); Gets the minimum coordinate dimensions of the geometric domain. 
\textit{xmin} is the minimum horizontal coordinate value and \textit{zmin} is the minimum vertical coordinate value
returned by the function.
\item  void getmaxcoord(double* xmax, double* zmax); Gets the maximum coordinate dimensions of the geometric domain.  
\textit{xmax} is the maximum horizontal coordinate value and \textit{zmax} is the maximum vertical coordinate value
returned by the function.
\end{itemize}

\section{Mesh Interface}
\begin{itemize}
\item void numnod( int *NumNodes ) ; Returns the number of nodes, \textit{NumNodes}, in the processor's partition of the mesh.  Since
 some nodes  exist on partition boundaries (i.e. shared by multiple processors) summing \textit{NumNodes} over all
processors will result in more nodes than exist in the total mesh. The IDs of the nodes on a processor are numbered between
one and \textit{NumNodes}.
\item void xyznod( int *iNode , double *X ) ; For input node ID \textit{iNode}, this function returns the coordinate location in 
the \textit{X} array.  The \textit{X} array should be of at least length 3.
\item void numfac( int *NumFaces ) ; Returns the number of faces, \textit{NumFaces}, in the processor's partition of the mesh. 
For a 2D mesh, the faces will all be elements. Since
 any face for a 2D mesh  exists only on  onepartition,  summing \textit{NumFaces} over all
processors will result in the total number of faces that exist in the mesh. The IDs of the faces on a processor are numbered between
one and \textit{NumFaces}.
\item void nodfac( int *iFace, int Nodes[4] ) ; For an input face ID, \textit{iFace}, this function returns the adjacent nodal IDs
in the \textit{Nodes} array.  
For mixed topology meshes the faces could be triangles or quadrilaterals so it is safest to have the \textit{Nodes} array to be of
length four.  The nodes IDs are returned in counter-clockwise order and it the face is a triangle then only the first three
values in the \textit{Nodes} array contain usable data.
\item void numglobalents(int * numnodes, int * numedges, int * numfaces, int * numregions); This function returns
the global number of nodes, edges, faces, and regions in the mesh in \textit{numnodes, numedges, numfaces}, and \textit{numregions}.
\item  void zonenod( int *iNod , int *iZone , int * iZoneDim); This function returns the model entity ID in 
\textit{iZone} and the model entity dimension in \textit{iZoneDim} for passed in mesh vertex \textit{iNod}.
\item void zonedg( int *iEdge , int *iZone , int * iZoneDim ); This function returns the model entity ID in 
\textit{iZone} and the model entity dimension in \textit{iZoneDim} for passed in mesh edge \textit{iEdge}.

\item void createsearchstructure(); This function sets up a search structure on each mesh partition.  
\item void deletesearchstructure(); This function deletes the search structure on each mesh partition.
\item void usesearchstructure(double* x, double* y, int* iFace); This function returns the face ID \textit{iFace}
of a mesh face that contains the given point \textit{(x,y)}.  The point \textit{(x,y)} is given in the
global coordinate system of the mesh.  The function returns -1 for \textit{iFace} if the points is not contained
in the domain of any mesh faces on the local processes partition.  Note  that multiple faces may contain
a given point (e.g. a mesh vertex coordinate).
\item void getelmsizes(int * iFace, double * sizes); For mesh face \textit{iFace}, this function returns an array
of doubles for the mesh size at each of the mesh vertices of the face.  
\end{itemize}





\section{Ordering Interface}

\begin{itemize}
\item   void createdofnumbering(int * numberingid, int * iper, int * jper,
                           int * dofspervertex, int * dofsperedge, 
                           int* dofsperface, int * dofsperregion, int * numdofs);
 This function creates a numbering with  ID \textit{numberingid}.  Currently, \textit{iper}
and \textit{jper} are not used as the periodic information is read in from the C1input file(???).
Eventually though if some orderings are periodic and others are not (e.g. a potential function)
than these options can be used to specify the difference in orderings. The other parameters
passed in (\textit{dofspervertex, dofsperedge, dofsperface,dofsperregion}) are to specify
how many dofs per mesh entity type (e.g. \textit{dofspervertex} would be 18 for a numvar=3 
vector and 0 for the other types.  The only returned value is \textit{numdofs} 
which is the total number of dofs associated with mesh entities that exist on the process that
the function is called on. This is also the allocated size of a vector on this process.  Note
though that a global sum of \textit{numdofs} on all processes will be greater than the total number
of global dofs unless it is a single process run. 

\item void deletedofnumbering(int * numberingid);
This function deletes the numbering associated with \textit{numberingid}.  It is an error
to query the SCOREC software with \textit{numberingid} unless another numbering is created
with this id.

\item  /* first case is for a single mesh entity assuming that all dofs
     of a mesh entity are numbered in order such that only
     a beginning number and an end number (or in our case, one
     beyond the end number) needs to be specified */
\item  void entdofs(int * numberingid, int * meshentid, int * meshentdim,
               int * begindofnumber, int * enddofnumberplusone);
     For \textit{numberingid}, of topological dimension \textit{meshentdim} with mesh entity
ID \textit{meshentid} this function outputs \textit{begindofnumber} which is the beginning of
the dof array location (stored contiguously) and \textit{enddofnumberplusone} is one
beyond the last dof array location.  For a numvar=1 ordering an example would be \textit{begindofnumber}=1
and \textit{enddofnumberplusone}=7. 

  /* fpr general case we can give the dof numbers on the closure of
     the passed in mesh entitiy but the dof numbers usually won't
     be in direct order so we need to know how big the array should
     be */
\item  void entnumdofs(int * numberingid, int * meshentid, int * meshentdim,
               int * closure, int * numdofs);
  /* for a given numbering the number of total dofs needed by this proc*/
\item  void numdofs(int * numberingid, int * numdofs);
  /* knowing how big the array should be and having it allocated
     properly already for a specified mesh entity, now we can
     fill in the dof numbers */
\item  void entdofsarray(int * numgeringid, int * meshentid, int * meshentdim,
                     int * closure, int * dofnumbersarray);
  /* for a given ordering figuring out which dofs belong to a processor
     for matrix solving is useful */
\item  void procdofs(int* numberingid, int * begindofnumber, int * enddofnumberplusone);
  /* for a given numbering the number of dofs assigned to a processor */
\item  void numprocdofs(int * numberingid, int * numprocdofs); 
\item  void numglobaldofs(int * numberingid, int * numglobaldofs);
\end{itemize}
\section{Vector Interface}
\begin{itemize}
\item   void createppplvec(double * id, int * orderingid);
\item   void deleteppplvec(double * id);
\item   void checkveccreated(double * id, int * iscreated);
\item   void sumshareddofs(double * id);
\item   void updateshareddofs(double * id);
\item   void checksamevec(double * id1, double * id2, int * i);//checks if id1 and id2 are the same, and sets *i=1 if true, *i=0 if false
\item   void updateids(double * oldid\_in, double * newid\_in);
\end{itemize}

\section{Matrix Interface}
\begin{itemize}
\item   void insertval(int * matrixid, double * val, int * row,
                   int * column, int * operation);

\item   void insertmultvals(int * matrixid, double * vals, int * iarray,
                       int * niarray, int * jarray, int * njarray,
                       int * operation);

\item   void setdiribc(int * matrixid, int * row);
\item   void setgeneralbc(int * matrixid, int * row, int * numvals,
                     int * columninfo, double * vals);
\item   void zerosuperluarray(int * matrixid, int * numberingid);
\item   void zeropetscarray(int * matrixid, int * numberingid);
\item   void zeromultiplyarray(int * matrixid, int * numberingid);
\item   void finalizearray(int * matrixid);
\item   void solve(int * matrixid, double * rhs\_sol, int * ier);
\item   void matrixvectormult(int * matrixid, double * inputvecid, double * outputvecid);
\item   void freesmo(int * matrixid);
\item   void matrixrank(int* matrixid, int * rank);
\item   void sludinit();
\item   void sludexit();
\item   void writematrixtofile(int * matrixid, int * fileid);
\end{itemize}


% appendix on modules that are used on different machines that M3D-C1 is installed on
\chapter{SCOREC Software Interface}
This appendix is meant to make sure that people do not have trouble determining which modules to use on 
which machines.  Note that this list may include modules that are not necessary for M3D-C$^1$.

\section{viz/m3d.pppl.gov}
The modules that I (Andy Bauer) have loaded on viz and m3d are  
 intel\_fc/9.0.033,
 intel\_cc/9.0.032,
 ncarg/4.4.1,
 hdf5/1.6.5,
 intel\_mkl/8.1.014,
   superlu\_dist\_2.0/20060102,
   intel\_vt/8.0.245,
   subversion/1.3.0,
   /parmetis/3.1,
  /autopack/1.3.2,
  petsc/2.3.3-p3,
  superlu\_3.0/20060102, and
  /zoltan/3.0 .

The commands that I use to load them are:
\begin{itemize}
\item      module load intel\_fc/9.0.033
\item       module load intel\_cc/9.0.032
\item       module load ncarg
\item       module load hdf5
\item       module load intel\_mkl/8.1.014
\item       module load superlu\_dist\_2.0/20060102
\item       module load intel\_vt
\item       module load subversion
\item       module load intel\_cc parmetis
\item       module load intel\_cc autopack
\item       module load petsc
\item       module load superlu\_3.0
\item       module load zoltan
\end{itemize}

\section{bassi.nersc.gov}
The modules that I (Andy Bauer) have loaded on bassi are 
null
   parmetis/3.1
   superlu\_dist/2.0\_64
   hdf5\_par/1.6.4
   netcdf/3.6.2
   ncar/4.4.2
   lapack/3.0
   petsc/2.3.3\_O
   zoltan/3.0 .

The commands that I use to load them are:
\begin{itemize}
\item module load parmetis
\item module load superlu\_dist
\item module load hdf5\_par
\item module load netcdf
\item module load ncar
\item module load petsc/2.3.3\_O
\item module load lapack
\item module load zoltan
\end{itemize}

