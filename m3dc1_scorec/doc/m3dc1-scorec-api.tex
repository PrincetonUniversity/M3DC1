%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{API Functions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The section describes the specification of API functions provided to the M3D-C1 Fortran driver. The function prototypes are declared in the file \texttt{m3dc1$\_$scorec.h}. Throughout this section, unless specified, mesh entities and DOF's are specified by a local ID. A word ``\emph{global}'' in a function name indicates that the function involves global operation or global data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Initialization and finalization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The functions initialize/finalize the PUMI operations.

\begin{verbatim}
// fortran name: m3dc1_domain_init
int m3dc1_scorec_init();
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Initialize the PUMI service for distributed model and mesh infrastructure. Note that MPI should be initialized prior to this function.

\begin{verbatim}
// fortran name: m3dc1_domain_finalize
int m3dc1_scorec_finalize();
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Finalize the PUMI service and clears all PUMI related data. Note that MPI finalization should follow.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Plane}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
int m3dc1_plane_setphi(
    int*  /* in */  planeid, 
    double*   /* in */  phi);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a plane ID and a double, set the phi value of the plane.

\begin{verbatim}
int m3dc1_plane_getphi(
    int*  /* in */  planeid, 
    double*  /* out */  phi);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a plane ID, return the value of phi of the plane.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Geometric model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
int m3dc1_model_load (char*  /* in */  model_file);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Load a geometric model from a model file that describes the geometry of the 2D cross section of the Tokamak. The file can contain
\begin{itemize}
\item parameters of the user specified analytic expression that defines a single loop as $R(t)=a_1 + a_2cos\left(t + a_3sin(t)\right)$ and $Z(t)= a_4 + a_5sin(t)$.
\item lists of geometric vertex and edges on the wall and vacuum boundaries and parameters of B-splines that define the shape of each edge.
\end{itemize}

\begin{verbatim}
int m3dc1_model_setnumplane (int*  /* in */  num_plane);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an integer \textit{num$\_$plane}, set the number of planes in 3D. For 2D, the number of plane is 1.

\begin{verbatim}
int m3dc1_model_getnumplane (int*  /* out */  num_plane);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Return the number of planes. For 2D, the number of plane is 1.

\begin{verbatim}
int m3dc1_model_getplaneid (int*  /* out */  plane_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Return the plane ID where the local process belongs. The plane ID starts from 0.

\begin{verbatim}
int m3dc1_model_getedge (
    int*  /* out */  left_edge, 
    int*  /* out */  right_edge,
    int*  /* out */  bottom_edge, 
    int*  /* out */  top_edge); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Return the four model edges of the rectangular domain.

\begin{verbatim}
int m3dc1_model_getmincoord (
    double*  /* out */  x_min, 
    double*  /* out */  y_min);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Return the minimum coordinate of the 2D cross section.
	      \textit{x\_min} is the minimum horizontal coordinate value. 
	      \textit{z\_min} is the minimum vertical coordinate value.

\begin{verbatim}
int m3dc1_model_getmaxcoord (
    double*  /* out */  x_max, 
    double*  /* out */  y_max);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Return the maximum coordinate of the 2D  cross section. 
          \textit{x\_max} is the maximum horizontal coordinate value. 
          \textit{Y\_max} is the maximum vertical coordinate value.

\begin{verbatim}
int m3dc1_model_print();
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Display the model information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mesh}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
When a mesh is distributed in parallel, a mesh entity can be uniquely identified in two ways: (i) an entity dimension and a global entity ID, or (ii) an entity dimension, a process rank and a local entity ID. The entity dimension is 0 for vertex, 1 for edge, 2 for face and 3 for region. For M3D-$C^1$, each mesh vertex has a $node$ serving as DOF holder. A mesh entity of highest dimension (face in 2D and region in 3D) is termed $element$. 

For a distributed mesh on multiple parts, mesh entities not on part boundaries are termed \textit{internal entity} and duplicated mesh entities along part boundaries are termed \textit{part boundary entity}. Among multiple copies of a part boundary entity, one entity is designated to be an \textit{owner copy} and is in charge of updating the rest of copies. The rest of entity copies are termed \textit{non-owned part boundary entity}. For a part boundary entity, duplicate \textit{off-part} copies are termed \textit{remote copy}. All internal entities are owner copies.

To avoid communications between the parts, it is beneficial to support the ability to have a copy of $non$-part boundary entities on other part, referred as $ghosting$. A \textit{ghost copy} is a read-only, duplicated, off-part internal entity copy including global ID, tag data, and field data. Similar to the ownership of part boundary entities, the original owner copy is designated as \emph{owner} of all \textit{ghost copies}.

\begin{verbatim}
int m3dc1_mesh_load (char*  /* in */  mesh_file);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Load a mesh from mesh file(s).

\begin{verbatim}
int m3dc1_mesh_build3d ();
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Construct 3D mesh from multiple 2D planes where each plane is loaded with 2D mesh. 

\begin{verbatim}
// fortran name: m3dc1_ghost_load
int m3dc1_ghost_create (int*  /* in */  n);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an integer \textit{n}, create $n$ ghost layer(s) in the mesh.

To perform ghosting with $d$-dimensional mesh, PUMI requires four input arguments: (i) ghost type $g$ (0$<$$g$$\le$$d$) for entity type to be ghosted, (ii) bridge type $b$ ($b$ $<$ $g$ and $b$$\ne$$g$),  (iii) the number of ghost layers $n$ measured from part boundary up to the number with which whole part can be ghosted, (iv) a boolean flag to indicate whether to include non-owned bridge entities or not in ghosting candidate computation. If true, all part boundary entities of bridge dimension are considered to construct ghost layer(s). If false, only $owner$  part boundary entities of bridge dimension are considered. 

In case of ghosting procedure in M3D-$C^1$, the bridge dimension, the ghost dimension, and the flag are, respectively, set to $d$-$1$, $d$, and $true$.

\begin{verbatim}
int m3dc1_ghost_delete ();
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Delete the ghost layer(s).

\begin{verbatim}
int m3dc1_mesh_getnumglobalent (
    int*  /* in*/  ent_dim, 
    int*  /* out */  num_global_ent);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension (0-3), return the number of $unique$ entities on all processes. \textit{Non-owned} part boundary entities and \textit{ghost copies} are not counted.

\begin{verbatim}
//fortran name: m3dc1_mesh_getnument
int m3dc1_mesh_getnumlocalent (
    int*  /* in*/  ent_dim, 
    int*  /* out */  num_local_ent);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension (0-3), return the number of entities on local process. 

\begin{verbatim}
int m3dc1_mesh_getnumownent (
    int*  /* in*/  ent_dim, 
    int*  /* out */  num_own_ent);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension (0-3), return the number of owner copies on local process.

\begin{verbatim}
int m3dc1_mesh_getnumghostent (
    int*  /* in*/  ent_dim, 
    int*  /* out */  num_ghost_ent);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension (0-3), return the number of ghost copies on local process.

\textcolor{red}{Added to support PIC}

\begin{verbatim}
int m3dc1_mesh_search (
    int*  /* in */   initial_simplex, 
    double*  /* in */  final_position, 
    int*  /* out */  final_simplex);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
\textcolor{red}{\textit{Kaushik will provide the specification}}

\begin{verbatim}
int m3dc1_mesh_write (
    char*  /* in */  filename, 
    int*  /* in */  option);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Write the mesh in file(s). Set the option to 0 for Paraview format (.vtk) and 1 for PUMI format (.smb).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mesh Adaptation and Solution Transfer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textcolor{red}{\textit{Mesh adaptation is not supported for ghosted mesh in the current version}}

\begin{verbatim}
int adapt_by_field (
    FieldID  /* in */  field_id, 
    double*  /* in */  psi0,  
    double*  /* in */  psil); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
The function adapts the mesh by the analytic size field defined in terms of  the solution field. The parameters in the analytic expression are defined in the file sizefieldParam. \textit{field$\_$id} is is the solution field. \textit{psi0} and \textit{psil} are two parameters to normalize the field value. The normalized field value is $\bar{psi} = (psi - psi0)/(psil - psi0)$.

\begin{verbatim}
int set_adapt_p (double*  /* in */  pp);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

\begin{verbatim}
int adapt_by_error_field (
    double*  /* in */  errorField, 
    double*  /* in */  errorAimed, 
    int*  /* in */  max_node, 
    int*  /* in */  option); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Set the option to 0 for local error control or 1 for global error control.

\begin{verbatim}
int set_mesh_size_bound (
    double*  /* in */  abs_size, 
    double*  /* in */  rel_size);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

\begin{verbatim}
int output_face_data (
    int*  /* in */  size, 
    double*  /* in */  data, 
    char*  /* in */  vtkfile);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

\begin{verbatim}
int sum_edge_data (
    double*  /* in */  data, 
    int*  /* in */  size);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

\begin{verbatim}
int get_node_error_from_elm (
    double*  /* in */  elm_data, 
    int*  /* in */  size, 
    double*  /* in */  nod_data);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mesh Entity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
int m3dc1_ent_getglobalid (
    int* /* in */ ent_dim, 
    int* /* in */ ent_id, 
    int* /* out */ glob_ent_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension and a local ID, return the global ID of the entity.

\begin{verbatim}
int m3dc1_ent_getgeomclass ( 
    int* /* in */ ent_dim, 
    int* /* in */ ent_id, 
    int* /* out */ geom_class_dim, 
    int* /* out */ geom_class_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension and a local ID, return the dimension and the ID of the geometric entity on which the mesh entity is classified. 

\begin{verbatim}
int m3dc1_ent_getadj (
    int* /* in */ ent_dim, 
    int* /* in */ ent_id, 
    int* /* in */ adj_dim,
    int*/* inout */ adj_ent,
    int* /* in */ adj_ent_allocated_size,
    int* /* out */ num_adj_ent); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local ID, and a dimension for adjacency, return the local ID's and the size of adjacenct entities. The array \emph{adj\_ent} contains adjacent entitites' local ID. The integers \emph{adj\_ent\_allocated\_size} and \emph{adj\_ent\_size} represent the size of memory allocated to \emph{adj\_ent} and the size of adjacent entities, respectively. \emph{adj\_ent\_allocated\_size} should be greater or equal to \emph{adj\_ent\_size}. \textcolor{red}{If a mesh is ghosted, the result may include ghost copies}.
	      
\begin{verbatim}
int m3dc1_ent_getnumadj (
    int* /* in */ ent_dim, 
    int* /* in */ ent_id, 
    int* /* in */ adj_dim,
    int* /* out */ num_adj_ent);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local ID, and a dimension for adjacency, return the number of adjacenct entities. \textcolor{red}{If a mesh is ghosted, the result may include ghost copies}
	      
\begin{verbatim}
int m3dc1_ent_getownpartid (
        int* /* in */ ent_dim, 
        int* /* in */ ent_id, 
        int* /* out */ owning_partid); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension and a local ID, return the owning part ID of the entity (the part ID where the owner copy exists). 

\begin{verbatim}
// fortran name: m3dc1_ent_ismine
int m3dc1_ent_isowner (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    int*  /* out */  is_owner); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension and a local ID, return $1$ if the entity is an owner copy. Otherwise, return $0$.

\begin{verbatim}
int m3dc1_ent_isghost (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    int*  /* out */  is_ghost); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension and a local ID, return $1$ if the entity is a ghost copy. Otherwise, return $0$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Node}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
int m3dc1_node_getglobalid (
    int* /* in */ ent_dim, 
    int* /* in */ ent_id, 
    int* /* out */ glob_ent_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a node dimension and a local ID, return the global ID of the node. The node dimension must be set to 0.

\begin{verbatim}
int m3dc1_node_getcoord (
    int* /* in */ node_id , 
    double* /* out */ coord ); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a local node ID, return the coordinate of the mesh vertex. The size of \textit{coord} is 3. For a 2D mesh, the value of $coord[2]$ is 0.0. 

\begin{verbatim}
int m3dc1_vertex_getnormvec (
    int* /* in */ node_id, 
    double* /* out */ xyz);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a local node ID, return the normal vector for a boundary mesh vertex defined on a 2D plane.

\begin{verbatim}
int m3dc1_node_getcurv (
    int* /* in */ node_id, 
    double* /* out */ curv); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

\begin{verbatim}
int m3dc1_vertex_isongeombdry (
    int* /* in */ node_id, 
    int* /* out */ on_geom_bdry)
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a local node ID, return an integer indicating whether the input node is on the geometric boundary (1) or not (0).

\begin{verbatim}
int m3dc1_node_write (
    const char* /* in */ filename, 
    int*  /* in */  start_index);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a file name and a starting local ID for nodes, write the node information in file(s). For each process $i$, the node information is written in ``filename-i''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Region}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
int m3dc1_region_getoriginalface( int* /* in */ elm, int* /* out */ fac);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Field}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
int m3dc1_field_getnewid (FieldID*  /* out */  field_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Return a new field ID which can be used to create a new field in \textit{m3dc1$\_$field$\_$create}. The data type $FieldID$ is equivalent to $integer$.

\begin{verbatim}
int m3dc1_field_create (
    FieldID*  /* in */  field_id, 
    const char*  /* in */  field_name, 
    int*  /* in */  num_values, 
    int*  /* in */  value_type, 
    int*  /* in */  num_dofs_per_value);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, field name, the number of values, value type (0: real, 1: complex), and the number of DOF's per value, create a field (vector) for all nodes (owner, non-owned part boundary and ghost). Note that PUMI allocates the memory for the array of field data. The size of field data is \textit{num$\_$values}$*$(\textit{value$\_$type}+1)$*$\textit{num$\_$dofs$\_$per$\_$value}$*$\textit{num$\_$local$\_$nodes}.

\begin{verbatim}
int m3dc1_field_delete (FieldID* /*in*/ field_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, delete the field and deallocate the memory.

\begin{verbatim}
int m3dc1_field_getinfo (
    FieldID*  /* in */  field_id, 
    char*  /* out*/  field_name, 
    int*  /* out*/  num_values, 
    int*  /* out*/  value_type, 
    int*  /* out*/  total_num_dof);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return field name, the number of values, value type (0: real, 1: complex), and the number of DOF's of each node (\textit{num$\_$values} $*$ \textit{num$\_$dofs$\_$per$\_$value}).

\begin{verbatim}
int m3dc1_field_exist (
    FieldID*  /* in */  field_id, 
    int*  /* out */  exist);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return 1 if the field exists. Otherwise, return 0.

\begin{verbatim}
int m3dc1_field_sync (FieldID* /* in */ field_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Synchronize the field between the owner copy, non-owned part boundary copies and ghost copies. The field values of the owner copies are copied to those of the non-owned part boundary copies and ghost copies.

\begin{verbatim}
int m3dc1_field_sum (FieldID* /* in */ field_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
When the values of the DOF's are obtained by integration over elements, the values are incomplete at the part boundary. The function performs parallel assembly and synchronize of the field on the part boundary by sending the field of non-owned part boundary copies to the owner copy. The values are summed up at the owner copy and sent back to to non-owned part boundary and ghost copies.  

\begin{verbatim}
int m3dc1_field_sumsq (
    FieldID*  /* in */  field_id, 
   double*  /* out */  sum);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the sum of square of DOF data for all $owner$ nodes.

\begin{verbatim}
int m3dc1_field_getglobaldofid ( 
    FieldID*  /* in */  field_id, 
    int* /* out */ start_dof_id, 
    int* /* out */ end_dof_id_plus_one); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the starting DOF ID and ending DOF ID plus one for global DOF's.

\begin{verbatim}
int m3dc1_field_getlocaldofid (
    FieldID*  /* in */  field_id, 
    int* /* out */ start_dof_id, 
    int* /* out */ end_dof_id_plus_one); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the starting DOF ID and ending DOF ID plus one for DOF's of all local nodes (owner, non-owned part bodarary and ghost). 

\begin{verbatim}
int m3dc1_field_getowndofid (
    FieldID*  /* in */  field_id, 
    int* /* out */ start_dof_id, 
    int* /* out */ end_dof_id_plus_one); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the starting DOF ID and ending DOF ID plus one for DOF's of owner nodes on local process.

\begin{verbatim}
int m3dc1_field_getghostdofid (
    FieldID*  /* in */  field_id, 
    int* /* out */ start_dof_id, 
    int* /* out */ end_dof_id_plus_one); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the starting DOF ID and ending DOF ID plus one for DOF's of ghost nodes on local process.

\textcolor{red}{Added to support PIC}

\begin{verbatim}
int m3dc1_field_getnumglobaldof (
    FieldID*  /* in */  field_id, 
    int*  /* out */  num_global_dof);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the number of global DOF's.

\begin{verbatim}
int m3dc1_field_getnumlocaldof (
    FieldID*  /* in */  field_id, 
    int*  /* out */  num_local_dof);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the number of DOF's of all local nodes (owner, non-owned part bodarary and ghost).

\begin{verbatim}
int m3dc1_field_getnumowndof (
    FieldID*  /* in */  field_id, 
    int*  /* out */  num_own_dof);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the number of DOF's of owner nodes on local process.

\begin{verbatim}
int m3dc1_field_getnumghostdof (
    FieldID*  /* in */  field_id, 
    int*  /* out */  num_ghost_dof);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the number of DOF's of ghost nodes on local process. 

\textcolor{red}{Added to support PIC}

\begin{verbatim}
int m3dc1_field_getdataptr (FieldID* field_id, double** pts);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the starting memory address of the array for field data.

\begin{verbatim}
int m3dc1_field_add (
    FieldID*  /* inout */  field_id_1, 
    FieldID*  /*in*/  field_id_2);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given two field ID's, add the values of the fields and save the resulting values into \textit{field$\_$id$\_$1}. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_mult (
    FieldID*  /*inout*/  field_id, 
    double*  /* in */  factor);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, multiply the values of the field by the factor. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_assign (
    FieldID*  /*inout*/  field_id, 
    double*  /* in */  value);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID and a real or complex value, set each DOF of the field to $value$. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_copy (
    FieldID*  /* inout */  field_id_1, 
    FieldID*  /*in*/  field_id_2);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given two field ID's, copy the values of \textit{field$\_$id$\_$2} to \textit{field$\_$id$\_$1}. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_retrieve (
    FieldID*  /*out*/  field_id, 
    double* /*out*/ data, 
    int* /* in */ n);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID and an integer $n$, set $data[i]$ to the $i^{th}$ DOF of the field, $0$ $\le$ $i$ $<$ $n$. 

\begin{verbatim}
int m3dc1_field_set (
    FieldID*  /*inout*/  field_id, 
    double* /*in*/ data, 
    int* /* in */ n);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID and a double array of size $n$, set the $i^{th}$ DOF of the field to $data[i]$, $0$ $\le$ $i$ $<$ $n$. 

\begin{verbatim}
int m3dc1_field_insert ( 
    FieldID* /* in */  field_id, 
    int*  /* in */  s, 
    int*  /* in */  n, 
    double*  /* in */  values, 
    int*  /* in */  scalar_type, 
    int*  /* in */  option);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, a starting local DOF ID $s$, a double array of size $n$, and a scalar type, if $option$ is 0, set DOF's at $[s,...,s+n-1]$ to $values[0,...,n-1]$. If $option$ is 1, add $values[0,...,n-1]$ to DOF's at $[s,...,s+n-1]$.

\begin{verbatim}
int m3dc1_field_isnan (
    FieldID* /* in */  field_id, 
    int*  /* in */  is_nan);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return 1 if any DOF value is $NaN$. Otherwise, return 0. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
// fortran name: m3dc1_field_sum_plane
int m3dc1_field_sumplane (FieldID*  /* in */  field_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Sum up the values of the field over a plane. The field of the mesh nodes with same $(R,Z)$ coordinate on different planes are summed. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies. It does not seem that this routine is used by M3D-C1.}

\begin{verbatim}
int m3dc1_field_printcompnorm (
    FieldID*  /* in */  field_id, 
    char*  /* in */  msg);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID and string message, print the message followed by the norm of the field. \textcolor{red}{The result does NOT include DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_max (
    FieldID* /* in */  field_id, 
    double*  /* out */  max_val, 
    double*  /* out */  min_val);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, return the $global$ maximum and minimum value of DOF's. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_print (FieldID*  /* in */  field_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, print the field information for each node. For instance, process ID, field name, global node ID, and DOF's. Note the number of DOF's per node should be 1, 2, 3, 4, 6, 8, 12, 18, or 24. Otherwise, return error. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

\begin{verbatim}
int m3dc1_field_write ( 
    FieldID*  /* in*/  field_id, 
    const char*  /* in */  filename, 
    int*  /* in */  start_index);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a field ID, file name and a starting local ID for nodes, write the field information in file(s). For each process $i$, the field information is written in ``filename-i''. \textcolor{red}{If a mesh is ghosted, the result includes DOF's of ghost copies}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Entity DOF's}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
int m3dc1_ent_getnumdof (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    FieldID*  /* in */  field_id, 
    int*  /* out */  num_dof);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local entity ID, and a field ID, return the number of DOF's associated with the entity.s

\begin{verbatim}
int m3dc1_ent_getlocaldofid (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    FieldID*  /* in */  field_id, 
    int*  /* out */  start_dof_id, 
    int*  /* out */  end_dof_id_plus_one);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local entity ID, and a field ID, return the starting local DOF ID and the ending local DOF ID plus one. 

\begin{verbatim}
int m3dc1_ent_getglobaldofid (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    FieldID*  /* in */  field_id, 
    int*  /* out */  start_dof_id, 
    int*  /* out */  end_dof_id_plus_one);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local entity ID, and a field ID, return the starting global DOF ID and the ending global DOF ID plus one. 

\begin{verbatim}
int m3dc1_ent_setdofdata (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    FieldID*  /* in */  field_id,
    int* /* in */  n, 
    double*  /* in */  data);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local entity ID, a field ID, and a double array of size $n$, set the $i^{th}$ DOF of the entity to $data[i]$, $0$ $\le$ $i$ $<$ $n$. $n$ should be identical to \textit{num$\_$dof} returned by \textit{m3dc1$\_$ent$\_$getnumdof}.

\begin{verbatim}
int m3dc1_ent_getdofdata (
    int*  /* in */  ent_dim, 
    int*  /* in */  ent_id, 
    FieldID*  /* in */  field_id,
    int* /* out */  n, 
    double*  /* out */  data);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given an entity dimension, a local entity ID, and a field ID, return the number of DOF ($n$) and a double array filled with DOF of the entity. $data[i]$ is set to the $i^{th}$ DOF of the entity, $0$ $\le$ $i$ $<$ $n$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PETSc Matrix and Solver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{verbatim}
int m3dc1_matrix_create (
        int*   /* in */  matrix_id,
        int*  /* in */  matrix_type,
        int*  /* in */  scalar_type,  
        FieldID*  /* in */  field_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, matrix type, scalar type (0: real, 1: complex) and a field ID for DOF ordering, create a PETSc matrix. The matrix type indicates the purpose of the matrix. 0 for matrix-vector multiplication and 1 for solver. If a matrix exists with a given matrix ID, return error. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$create}.

\begin{verbatim}
int m3dc1_matrix_delete (int*  /* in */  matrix_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, delete the matrix. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$delete}.
	    
\begin{verbatim}
int m3dc1_matrix_freeze (int*  /* in */  matrix_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Finalize the matrix such that no more values can be inserted into the matrix and no more boundary conditions can be applied to the matrix. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$freeze}.

\begin{verbatim}
int m3dc1_matrix_insert (
    int*  /* in */  matrix_id, 
    int*  /* in */  row, 
    int*  /* in */  column, 
    int*  /* in */  scalar_type, 
    double*  /* in */  value);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Insert or overwrite \textit{val} to the matrix at (\textit{row},\textit{column}).
\textit{row} and \textit{column} are global DOF ID associated with the matrix.
\textit{scalar$\_$type} is 0 for real or 1 for complex. A real type can be inserted into a complex matrix but a complex type cannot be inserted into a real matrix. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$insert}.

\begin{verbatim}
int m3dc1_matrix_add (
    int*  /* in */  matrix_id, 
    int*  /* in */  row, 
    int*  /* in */  column, 
    int*  /* in */  scalar_type, 
    double*  /* in */  val);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Add \textit{val} to the existing value of matrix at (\textit{row},\textit{column}).
\textit{row} and \textit{column} are global DOF ID associated with the matrix.
\textit{scalar$\_$type} is 0 for real or 1 for complex. A real type can be inserted into a complex matrix but a complex type cannot be inserted into a real matrix.  The equivalane API for Trilinos is not available.

\begin{verbatim}
int m3dc1_matrix_insertblock (
    int*  /* in */  matrix_id, 
    int*  /* in */  ielm, 
    int*  /* in */  row_index, 
    int*  /* in */  column_index, 
    double*  /* in */  values);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, a local element ID, row variable index, colume variable index and values, add values to the matrix corresponding to the nodes of the element. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$addblock}.
 
\begin{verbatim}
int m3dc1_matrix_setbc (
    int*  /* in */  matrix_id, 
    int*  /* in */  local_row_index);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID and a local row index, zero out all off-diagonal values in the row of the matrix and set the diagonal value to one. The operation is carried out during finalizing the matrix. It will overwrite other insertion operations to the local row of the matrix. For complex-valued matrix, the real part of the diagonal is set to one and the imaginary part is set to zero.
This function should be called on all processes that use the DOF numbering associated with the matrix row. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$setbc}.

\begin{verbatim}
int m3dc1_matrix_setlaplacebc (
    int*  /* in */  matrix_id, 
    int*  /* in */  row, 
    int*  /* in */  size, 
    int*  /* in */  columns, 
    double*  /* in */  values);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Set multiple values for the row of the matrix.
The argument \textit{size} is the  number of values to be inserted.
\textit{columns} specifies which columns to set the values. \textit{values} are the values to be set which must be in the order of the \textit{columns}.
If real values are inserted into a complex matrix, the corresponding imaginary parts are set to zero. The operation is carried out during finalizing the matrix. 
This function will overwrite other insertion operations to the row. This function should be called on all processes that use the DOF numbering associated with the matrix row. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$setlaplacebc}.

\begin{verbatim}
int m3dc1_matrix_multiply (
    int*  /* in */  matrix_id, 
    FieldID*  /* in */  in_field_id, 
    FieldID*  /* out */  out_field_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, an input field ID, and an output field ID, perform the matrix-vector multiplication and return the output in the output field.
If any of input matrix or input field is complex-valued, the output field must be complex-valued. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$multiply}.

\begin{verbatim}
int m3dc1_matrix_solve (
        int*  /* in */  matrix_id, 
        FieldID*  /* inout */  rhs_sol); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID and a field ID, solve the global discrete equation $Ax=b$ and overwrite the solution into the field. The equivalane API for Trilinos is \textit{m3dc1$\_$solver$\_$aztec}.


\begin{verbatim}
int m3dc1_matrix_getiternum (
    int*  /* in */  matrix_id,
    int*  /* out */  iter_num); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, return the number of iterations of solver operation. The equivalane API for Trilinos is \textit{m3dc1$\_$solver$\_$getnumiter}.

\begin{verbatim}
int m3dc1_matrix_flush(int*  /* in */  matrix_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
 The equivalane API for Trilinos is not available.

\begin{verbatim}
int m3dc1_matrix_setassembleoption(int*  /* in */  op);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
 The equivalane API for Trilinos is not available.

\begin{verbatim}
int m3dc1_matrix_print(int*  /* in */  matrix_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, print the $non$-$zero$ matrix value along with global row/colume index. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$print}.

\begin{verbatim}
int m3dc1_matrix_write (
    int*  /* in */  matrix_id, 
    const char*  /* in */  file_name, 
    int*  /* in */  start_index);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, file name and a starting local ID for nodes, write the $non$-$zero$ matrix values in file(s). For each process $i$, the matrix information is written in ``filename-i''. The equivalane API for Trilinos is \textit{m3dc1$\_$epetra$\_$write}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Trilinos Matrix and Solver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
int m3dc1_epetra_create(
    int*  /* in */  matrix_id, 
    int*  /* in */  matrix_type, 
    int*  /* in */  scalar_type, 
    FieldID*  /* in */  field_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, matrix type, scalar type (0: real, 1: complex) and a field ID for DOF ordering, create a Trilinos Epetra matrix. The matrix type indicates the purpose of the matrix. 0 for matrix-vector multiplication and 1 for solver. If a matrix exists with a given matrix ID, return error. Note that the complex value is not supported for Trilinos.

\begin{verbatim}
int m3dc1_epetra_delete (int*  /* in */  matrix_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, delete the matrix. 

\begin{verbatim}
int m3dc1_epetra_freeze (int*  /* in */  matrix_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, finalize the matrix such that no more values can be inserted into the matrix and no more boundary conditions can be applied to the matrix.

\begin{verbatim}
int m3dc1_epetra_insert (
    int*  /* in */  matrix_id, 
    int*  /* in */  row, 
    int*  /* in */  column, 
    int*  /* in */  scalar_type, 
    double*  /* in */  val);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Insert or overwrite \textit{val} to the matrix at (\textit{row},\textit{column}).
\textit{row} and \textit{column} are global DOF ID associated with the matrix.
\textit{scalar$\_$type} is 0 for real or 1 for complex. Note that the complex value is not supported for Trilinos.

\begin{verbatim}
int m3dc1_epetra_addblock(
    int*  /* in */  matrix_id,
    int*  /* in */  ielm, 
    int*  /* in */  row_index, 
    int*  /* in */  column_index, 
    double*  /* in */  values);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, a local element ID, row variable index, colume variable index, and values, add values to the matrix corresponding to the nodes of the element. 

\begin{verbatim}
int m3dc1_epetra_setbc (
    int*  /* in */  matrix_id, 
    int*  /* in */  row);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Zero out all off-diagonal values in the \textit{row} of the matrix and set the diagonal value to one. The operation is carried out during finalizing the matrix. It will overwrite other insertion operations to the row. For complex-valued matrix, the real part of the diagonal is set to one and the imaginary part is set to zero.
This function should be called on all processes that use the DOF numbering associated with the matrix row. 

\begin{verbatim}
int m3dc1_epetra_setlaplacebc (
    int*  /* in */  matrix_id, 
    int*  /* in */  row, 
    int*  /* in */  size, 
    int*  /* in */  columns, 
    double*  /* in */  values);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Set multiple values for the row of the matrix. The argument \textit{size} is the  number of values to be inserted. \textit{columns} specifies which columns to set the values. \textit{values} are the values to be set which must be in the order of the \textit{columns}. If real values are inserted into a complex matrix, the corresponding imaginary parts are set to zero. The operation is carried out during finalizing the matrix. This function will overwrite other insertion operations to the row. This function should be called on all processes that use the DOF numbering associated with the matrix row. 

\begin{verbatim}
int m3dc1_epetra_multiply (
    int*  /* in */  matrix_id, 
    FieldID*  /* in */  in_field_id, 
    FieldID*  /* out */  out_field_id); 
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, an input field ID, and an output field ID, perform the matrix-vector multiplication and return the output in the output field.
If any of input matrix or input field is complex-valued, the output field must be complex-valued.

\begin{verbatim}
int m3dc1_solver_aztec ( 
    int*  /* in */  matrix_id, 
    FieldID*  /* in */  x_field_id, 
    FieldID*  /* in */  b_field_id, 
    int*  /* out */  num_iter, 
    double*  /* in */  tolerance,
    const char*  /* in */  krylov_solver, 
    const char*  /* in */  preconditioner, 
    const char*  /* in */  sub_dom_solver,
    int*  /* in */  overlap, 
    int*  /* in */  graph_fill, 
    double*  /* in */  ilu_drop_tol,  
    double*  /* in */  ilu_fill,
    double*  /* in */  ilu_omega, 
    int*  /* in */  poly_ord);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, $x$ field ID, $b$ field ID, and various options for aztec solver, solve the global discrete equation $Ax=b$ and write the solution into the field $b$. The solver options are the following:
\begin{itemize}
\item num$\_$iter: maximum number of iteration
\item tolerance: solver tolerance
\item krylov$\_$solver: krylov solver
\item preconditioner: preconditioner
\item sub$\_$dom$\_$solver: subdomain solver in preconditioner
\item overlap: subdomain overlap
\item graph$\_$fill: graph fill level
\item ilu$\_$drop$\_$tol: ILU drop tolerance
\item ilu$\_$fill: ILU fill level
\item ilu$\_$omega: relaxation parameter for rILU
\item poly$\_$ord: polynomial order for certain preconditioners
\end{itemize}

For further information on solver options, see the Trilinos User's Guide.

\begin{verbatim}
int m3dc1_solver_getnumiter (
    int*  /* in */  matrix_id, 
    int*  /* out */  num_iter);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, return the number of iterations of solver operation.

\begin{verbatim}
int m3dc1_epetra_print (int*  /* in */  matrix_id);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, print the matrix value.

\begin{verbatim}
int m3dc1_epetra_write (
    int*  /* in */  matrix_id, 
    const char*  /* in */  filename, 
    int*  /* in */  skip_zero,
    int*  /* in */  start_index);
\end{verbatim}\vspace{-.5cm}\hspace{1cm}
Given a matrix ID, file name, an integer flag, and a starting local ID for nodes, write the matrix values in file(s). For each process $i$, the matrix information is written in ``filename-i''. If \textit{skip$\_$zero} is 0, all matrix values are written. If 1, only $non$-$zero$ values are written.

